/*
 * Copyright 2016 The Cartographer Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cartographer_ros/split_string.h"
#include "gflags/gflags.h"
#include "glog/logging.h"
#include "cartographer/mapping/proto/pose_graph.pb.h"
#include "cartographer/transform/transform_interpolation_buffer.h"
#include "cartographer/io/proto_stream.h"
#include "cartographer/io/proto_stream_deserializer.h"
#include "cartographer/common/make_unique.h"
#include "cartographer_ros/time_conversion.h"
#include "cartographer_ros/msg_conversion.h"
#include "cartographer_ros/urdf_reader.h"
#include "ros/ros.h"
#include "rosbag/bag.h"
#include "rosbag/view.h"
#include "tf2_eigen/tf2_eigen.h"
#include "tf2_msgs/TFMessage.h"
#include "tf2_ros/buffer.h"
#include "urdf/model.h"
#include <iostream>
#include <fstream>

DEFINE_string(configuration_directory, "",
              "First directory in which configuration files are searched, "
              "second is always the Cartographer installation to allow "
              "including files from there.");
DEFINE_string(configuration_basename, "",
              "Basename, i.e. not containing any directory prefix, of the "
              "configuration file.");
DEFINE_string(
    urdf_filename, "",
    "URDF file that contains static links for your sensor configuration.");
DEFINE_string(bag_filenames, "",
              "Bags to process, must be in the same order as the trajectories "
              "in 'pose_graph_filename'.");
DEFINE_string(pose_graph_filename, "",
              "Proto stream file containing the pose graph.");
DEFINE_bool(use_bag_transforms, true,
            "Whether to read and use the transforms from the bag.");
DEFINE_string(output_file_prefix, "",
              "Will be prefixed to all output file names and can be used to "
              "define the output directory. If empty, the first bag filename "
              "will be used.");
DEFINE_string(output_dir, "",
              "output_dir");

void WritePlyBinary(const std::vector<Eigen::Vector3f>& points, const char* output_file) {
  std::cout << "writing cloud with size " << points.size() << std::endl;
  std::ostringstream stream;
  stream << "ply\n"
         << "format binary_little_endian 1.0\n"
         << "comment generated by Cartographer\n"
         << "element vertex " << std::setw(15) << std::setfill('0')
         << points.size() << "\n"
         << "property float x\n"
         << "property float y\n"
         << "property float z\n"
         << "end_header\n";
  const std::string out = stream.str();
  std::ofstream ply_file;
  ply_file.open(output_file);
  ply_file << out; 
  for(size_t i = 0; i < points.size(); ++i) {
    Eigen::Vector3f point = points[i];
    char buffer[12];
    memcpy(buffer, &point[0], sizeof(float));
    memcpy(buffer + 4, &point[1], sizeof(float));
    memcpy(buffer + 8, &point[2], sizeof(float));
    ply_file.write(buffer, 12);
  }
  ply_file.close();
}

int main(int argc, char** argv) {
  FLAGS_alsologtostderr = true;
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);

  CHECK(!FLAGS_configuration_directory.empty())
      << "-configuration_directory is missing.";
  CHECK(!FLAGS_configuration_basename.empty())
      << "-configuration_basename is missing.";
  CHECK(!FLAGS_bag_filenames.empty()) << "-bag_filenames is missing.";
  CHECK(!FLAGS_pose_graph_filename.empty())
      << "-pose_graph_filename is missing.";
  CHECK(!FLAGS_output_dir.empty())
      << "-output_dir is missing.";

  ::cartographer::mapping::proto::PoseGraph pose_graph = ::cartographer::io::DeserializePoseGraphFromFile(FLAGS_pose_graph_filename);

  const ::cartographer::mapping::proto::Trajectory& trajectory_proto = pose_graph.trajectory(0);
  if (trajectory_proto.node_size() == 0) {
    std::cout << "empty trajectory " << std::endl;
    return 1;
  }
  std::cout << "there are " << trajectory_proto.node_size() << " nodes " << std::endl;

  tf2_ros::Buffer tf_buffer;
  cartographer_ros::ReadStaticTransformsFromUrdf(FLAGS_urdf_filename, &tf_buffer);
  const ::cartographer::transform::TransformInterpolationBuffer transform_interpolation_buffer(trajectory_proto);
  rosbag::Bag bag;
  bag.open(FLAGS_bag_filenames);
  rosbag::View view(bag);
  const ::ros::Time begin_time = view.getBeginTime();
  const double duration_in_seconds = (view.getEndTime() - begin_time).toSec();
  std::string tracking_frame = "base_link";
  std::vector<Eigen::Vector3f> points_result;
  points_result.reserve(1e7);
  ::cartographer::transform::Rigid3d kf_tracking_to_map;
  bool saved = true;
  std::ofstream optimized_pose;
  //optimized_pose.open("/home/aibee/Data/wanda_f1/optimized_pose.txt");
  //std::string base_output = "/home/aibee/Data/wanda_f1/velodyne_points";
  //optimized_pose.open("/home/aibee/Data/beiti_test/optimized_pose.txt");
  //std::string base_output = "/home/aibee/Data/beiti_test/velodyne_points";
  //optimized_pose.open("/home/aibee/Data/beiti_record1/optimized_pose.txt");
  //std::string base_output = "/home/aibee/Data/beiti_record1/velodyne_points";
  optimized_pose.open(FLAGS_output_dir+"optimized_pose.txt");
  std::string base_output = FLAGS_output_dir+"velodyne_points";
  char name[2000];
  std::vector<::ros::Time> kf_times;
  std::ifstream kf_times_f;
  kf_times_f.open(FLAGS_output_dir + "kf_times.txt");
  {
    char line[1024];
    while(kf_times_f.getline(line,1024)){
      std::stringstream ss(line);
      long time;
      ss >> time;
      ::ros::Time t(double(time/1.e9));
      kf_times.push_back(t);
    }
  }
  optimized_pose << kf_times.size() << "\n";
  // initialize
  size_t current_kf_index = 0;
  //std::cout << "earliest time  " << transform_interpolation_buffer.earliest_time() << std::endl;
  ::cartographer::common::Time kf_time = ::cartographer_ros::FromRos(kf_times[0]);
  //std::cout << "time is " << kf_time << std::endl;
  if (!transform_interpolation_buffer.Has(kf_time)) {
    std::cout << "first kf time is " << kf_time << std::endl;
    std::cout << "first kf time not valid" << std::endl;
    kf_time = transform_interpolation_buffer.earliest_time();
    //exit(1);
  }
  kf_tracking_to_map = transform_interpolation_buffer.Lookup(kf_time);

  for (const rosbag::MessageInstance& message : view) {
    //std::unique_ptr<::cartographer::io::PointsBatch> points_batch;   
    if (message.isType<sensor_msgs::PointCloud2>()) {

      double current_message_time = message.instantiate<sensor_msgs::PointCloud2>()->header.stamp.toSec();
      //if ((message.instantiate<sensor_msgs::PointCloud2>()->header.stamp - begin_time).toSec() > 30) {
      //  break; 
      //}
      if (current_kf_index < kf_times.size()-1) {
        if (fabs(current_message_time-kf_times[current_kf_index].toSec()) > fabs(current_message_time-kf_times[current_kf_index+1].toSec())) {
          Eigen::Matrix4f transformation = Eigen::Matrix4f::Identity();
          transformation.block<3,3>(0,0) = kf_tracking_to_map.rotation().cast<float>().normalized().toRotationMatrix();
          transformation.block<3,1>(0,3) = kf_tracking_to_map.translation().cast<float>();
          for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
              optimized_pose << transformation(i,j) << " "; 
            }
            optimized_pose << "\n";
          }

          sprintf(name, "%s/%06d.ply", base_output.c_str(), int(current_kf_index));
          saved = true;
          WritePlyBinary(points_result, name);
          std::vector<Eigen::Vector3f>().swap(points_result);
          current_kf_index++; 
          kf_time = ::cartographer_ros::FromRos(kf_times[current_kf_index]);
          if (!transform_interpolation_buffer.Has(kf_time)) {
            std::cout << "kf " << current_kf_index << " time not valid" << std::endl;
            exit(1);
          }
          kf_tracking_to_map = transform_interpolation_buffer.Lookup(kf_time);
          std::cout << "current kf index " << current_kf_index << std::endl;
        }
      }
      //std::cout << "processed time " << (message.instantiate<sensor_msgs::PointCloud2>()->header.stamp - begin_time).toSec() << std::endl;
      ::cartographer::sensor::PointCloudWithIntensities point_cloud;
      ::cartographer::common::Time point_cloud_time;
      std::tie(point_cloud, point_cloud_time) = cartographer_ros::ToPointCloudWithIntensities(*message.instantiate<sensor_msgs::PointCloud2>());
      CHECK_EQ(point_cloud.intensities.size(), point_cloud.points.size());
      const ::cartographer::common::Time time = point_cloud_time;
      if (!transform_interpolation_buffer.Has(time)) {
        continue; 
      }
      const ::cartographer::transform::Rigid3d tracking_to_map = transform_interpolation_buffer.Lookup(time);
      const ::cartographer::transform::Rigid3d sensor_to_tracking = ::cartographer_ros::ToRigid3d(tf_buffer.lookupTransform(tracking_frame, message.instantiate<sensor_msgs::PointCloud2>()->header.frame_id, ::cartographer_ros::ToRos(time)));
      //const ::cartographer::transform::Rigid3f sensor_to_map = (tracking_to_map*sensor_to_tracking).cast<float>();
      const ::cartographer::transform::Rigid3f sensor_to_kf_tracking = (kf_tracking_to_map.inverse()*tracking_to_map*sensor_to_tracking).cast<float>();
      // check if need to create new kf
      for (size_t i = 0; i < point_cloud.points.size(); ++i) {
        Eigen::Vector3f point = sensor_to_tracking.cast<float>()*point_cloud.points[i].head<3>();
        if(point[0]>0||point.norm()<4.0)
          continue;
        if (point_cloud.points[i].head<3>().norm() < 20) 
          points_result.push_back(sensor_to_kf_tracking*point_cloud.points[i].head<3>());
      }
      saved = false;
    }
  }
  if (!saved) {
    sprintf(name, "%s/%06d.ply", base_output.c_str(), int(current_kf_index));
    WritePlyBinary(points_result, name);
    Eigen::Matrix4f transformation = Eigen::Matrix4f::Identity();
    transformation.block<3,3>(0,0) = kf_tracking_to_map.rotation().cast<float>().normalized().toRotationMatrix();
    transformation.block<3,1>(0,3) = kf_tracking_to_map.translation().cast<float>();
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        optimized_pose << transformation(i,j) << " "; 
      }
      optimized_pose << "\n";
    }
  }
  optimized_pose.close();
  //WritePlyBinary(points_result, "/home/aibee/cartographer_ws/result.ply");
}
