/*
 * Copyright 2016 The Cartographer Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cartographer_ros/split_string.h"
#include "gflags/gflags.h"
#include "glog/logging.h"
#include "cartographer/mapping/proto/pose_graph.pb.h"
#include "cartographer/transform/transform_interpolation_buffer.h"
#include "cartographer/io/proto_stream.h"
#include "cartographer/io/proto_stream_deserializer.h"
#include "cartographer/common/make_unique.h"
#include "cartographer_ros/time_conversion.h"
#include "cartographer_ros/msg_conversion.h"
#include "cartographer_ros/urdf_reader.h"
#include "ros/ros.h"
#include "rosbag/bag.h"
#include "rosbag/view.h"
#include "tf2_eigen/tf2_eigen.h"
#include "tf2_msgs/TFMessage.h"
#include "tf2_ros/buffer.h"
#include "urdf/model.h"
#include <iostream>
#include <fstream>

DEFINE_string(configuration_directory, "",
              "First directory in which configuration files are searched, "
              "second is always the Cartographer installation to allow "
              "including files from there.");
DEFINE_string(configuration_basename, "",
              "Basename, i.e. not containing any directory prefix, of the "
              "configuration file.");
DEFINE_string(
    urdf_filename, "",
    "URDF file that contains static links for your sensor configuration.");
DEFINE_string(bag_filenames, "",
              "Bags to process, must be in the same order as the trajectories "
              "in 'pose_graph_filename'.");
DEFINE_string(pose_graph_filename, "",
              "Proto stream file containing the pose graph.");
DEFINE_bool(use_bag_transforms, true,
            "Whether to read and use the transforms from the bag.");
DEFINE_string(output_file_prefix, "",
              "Will be prefixed to all output file names and can be used to "
              "define the output directory. If empty, the first bag filename "
              "will be used.");
DEFINE_string(output_dir, "",
              "output_dir with last slash");

void WritePlyBinary(const std::vector<Eigen::Vector3f>& points, std::string output_file) {
  std::ostringstream stream;
  stream << "ply\n"
         << "format binary_little_endian 1.0\n"
         << "comment generated by Cartographer\n"
         << "element vertex " << std::setw(15) << std::setfill('0')
         << points.size() << "\n"
         << "property float x\n"
         << "property float y\n"
         << "property float z\n"
         << "end_header\n";
  const std::string out = stream.str();
  std::ofstream ply_file;
  ply_file.open(output_file);
  ply_file << out; 
  for(size_t i = 0; i < points.size(); ++i) {
    Eigen::Vector3f point = points[i];
    char buffer[12];
    memcpy(buffer, &point[0], sizeof(float));
    memcpy(buffer + 4, &point[1], sizeof(float));
    memcpy(buffer + 8, &point[2], sizeof(float));
    ply_file.write(buffer, 12);
  }
  ply_file.close();
}

int main(int argc, char** argv) {
  FLAGS_alsologtostderr = true;
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);

  CHECK(!FLAGS_configuration_directory.empty())
      << "-configuration_directory is missing.";
  CHECK(!FLAGS_configuration_basename.empty())
      << "-configuration_basename is missing.";
  CHECK(!FLAGS_bag_filenames.empty()) << "-bag_filenames is missing.";
  CHECK(!FLAGS_output_dir.empty()) << "-output_dir is missing.";
  CHECK(!FLAGS_pose_graph_filename.empty())
      << "-pose_graph_filename is missing.";

  ::cartographer::mapping::proto::PoseGraph pose_graph = ::cartographer::io::DeserializePoseGraphFromFile(FLAGS_pose_graph_filename);

  const ::cartographer::mapping::proto::Trajectory& trajectory_proto = pose_graph.trajectory(0);
  if (trajectory_proto.node_size() == 0) {
    std::cout << "empty trajectory " << std::endl;
    return 1;
  }
  std::cout << "there are " << trajectory_proto.node_size() << " nodes " << std::endl;

  tf2_ros::Buffer tf_buffer;
  cartographer_ros::ReadStaticTransformsFromUrdf(FLAGS_urdf_filename, &tf_buffer);
  const ::cartographer::transform::TransformInterpolationBuffer transform_interpolation_buffer(trajectory_proto);
  std::cout << "openning bags " << std::endl;
  rosbag::Bag bag;
  bag.open(FLAGS_bag_filenames);
  std::cout << "bag opened " << std::endl;
  rosbag::View view(bag);
  const ::ros::Time begin_time = view.getBeginTime();
  const double duration_in_seconds = (view.getEndTime() - begin_time).toSec();
  std::string tracking_frame = "base_link";
  std::vector<Eigen::Vector3f> points_result;
  bool initial = true;
  std::ofstream kf_times;
  std::string kf_time_filename = FLAGS_output_dir + "kf_times.txt";
  kf_times.open(kf_time_filename);
  ::cartographer::transform::Rigid3d current_tracking_to_map;
  //int process_duration = 30;
  for (const rosbag::MessageInstance& message : view) {
    //std::unique_ptr<::cartographer::io::PointsBatch> points_batch;   
    if (message.isType<sensor_msgs::PointCloud2>()) {

      //if ((message.instantiate<sensor_msgs::PointCloud2>()->header.stamp - begin_time).toSec() > process_duration) {
      //  break; 
      //}
      std::cout << "processed time " << (message.instantiate<sensor_msgs::PointCloud2>()->header.stamp - begin_time).toSec() << std::endl;
      ::cartographer::sensor::PointCloudWithIntensities point_cloud;
      ::cartographer::common::Time point_cloud_time;
      std::tie(point_cloud, point_cloud_time) = cartographer_ros::ToPointCloudWithIntensities(*message.instantiate<sensor_msgs::PointCloud2>());
      CHECK_EQ(point_cloud.intensities.size(), point_cloud.points.size());
      const ::cartographer::common::Time time = point_cloud_time;
      if (!transform_interpolation_buffer.Has(time)) {
        continue; 
      }
      const ::cartographer::transform::Rigid3d tracking_to_map = transform_interpolation_buffer.Lookup(time);
      const ::cartographer::transform::Rigid3d sensor_to_tracking = ::cartographer_ros::ToRigid3d(tf_buffer.lookupTransform(tracking_frame, message.instantiate<sensor_msgs::PointCloud2>()->header.frame_id, ::cartographer_ros::ToRos(time)));
      const ::cartographer::transform::Rigid3f sensor_to_map = (tracking_to_map*sensor_to_tracking).cast<float>();
      if (initial) {
        current_tracking_to_map = tracking_to_map; 
        initial = false; 
        long time_ns = static_cast<long>(::cartographer_ros::ToRos(point_cloud_time).toSec()*1e9);
        kf_times << time_ns << "\n"; 
      }
      // check if need to create new kf
      const ::cartographer::transform::Rigid3d delta_transform = current_tracking_to_map.inverse()*tracking_to_map;
      Eigen::AngleAxisd angle_axis(delta_transform.rotation());
      //if (delta_transform.translation().norm() > 2 || fabs(angle_axis.angle()) > 60.f*M_PI/180) {
      if (delta_transform.translation().norm() > 1 || fabs(angle_axis.angle()) > 60.f*M_PI/180) {
        std::cout << "created new kf" << std::endl;
        current_tracking_to_map  = tracking_to_map;
        long long time_ns = static_cast<long long>(::cartographer_ros::ToRos(point_cloud_time).toSec()*1e9);
        kf_times << time_ns << "\n"; 
      }
    }
  }
  //WritePlyBinary(points_result, "/home/aibee/cartographer_ws/result.ply");
  kf_times.close();
}
