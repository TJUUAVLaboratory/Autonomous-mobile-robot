/*
 * Copyright 2016 The Cartographer Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cartographer_ros/split_string.h"
#include "gflags/gflags.h"
#include "glog/logging.h"
#include "cartographer/mapping/proto/pose_graph.pb.h"
#include "cartographer/transform/transform_interpolation_buffer.h"
#include "cartographer/io/proto_stream.h"
#include "cartographer/io/proto_stream_deserializer.h"
#include "cartographer/common/make_unique.h"
#include "cartographer_ros/time_conversion.h"
#include "cartographer_ros/msg_conversion.h"
#include "cartographer_ros/urdf_reader.h"
#include "ros/ros.h"
#include "rosbag/bag.h"
#include "rosbag/view.h"
#include "tf2_eigen/tf2_eigen.h"
#include "tf2_msgs/TFMessage.h"
#include "tf2_ros/buffer.h"
#include "urdf/model.h"
#include <iostream>
#include <fstream>

DEFINE_string(configuration_directory, "",
              "First directory in which configuration files are searched, "
              "second is always the Cartographer installation to allow "
              "including files from there.");
DEFINE_string(configuration_basename, "",
              "Basename, i.e. not containing any directory prefix, of the "
              "configuration file.");
DEFINE_string(
    urdf_filename, "",
    "URDF file that contains static links for your sensor configuration.");
DEFINE_string(pose_graph_filename, "",
              "Proto stream file containing the pose graph.");
DEFINE_bool(use_bag_transforms, true,
            "Whether to read and use the transforms from the bag.");
DEFINE_string(output_file_prefix, "",
              "Will be prefixed to all output file names and can be used to "
              "define the output directory. If empty, the first bag filename "
              "will be used.");
DEFINE_string(output_dir, "",
              "output_dir with last slash");

void WritePlyBinary(const std::vector<Eigen::Vector3f>& points, std::string output_file) {
  std::ostringstream stream;
  stream << "ply\n"
         << "format binary_little_endian 1.0\n"
         << "comment generated by Cartographer\n"
         << "element vertex " << std::setw(15) << std::setfill('0')
         << points.size() << "\n"
         << "property float x\n"
         << "property float y\n"
         << "property float z\n"
         << "end_header\n";
  const std::string out = stream.str();
  std::ofstream ply_file;
  ply_file.open(output_file);
  ply_file << out; 
  for(size_t i = 0; i < points.size(); ++i) {
    Eigen::Vector3f point = points[i];
    char buffer[12];
    memcpy(buffer, &point[0], sizeof(float));
    memcpy(buffer + 4, &point[1], sizeof(float));
    memcpy(buffer + 8, &point[2], sizeof(float));
    ply_file.write(buffer, 12);
  }
  ply_file.close();
}
::cartographer::transform::Rigid3d GetPose(::cartographer::common::Time &pano_t,
std::vector<::cartographer::transform::TransformInterpolationBuffer> &transform_interpolation_buffers){
  ::cartographer::transform::Rigid3d pano_tracking_to_map;
  bool have_time = false;
  for(size_t i=0;i<transform_interpolation_buffers.size();++i){
    if(transform_interpolation_buffers[i].Has(pano_t)){
      pano_tracking_to_map = transform_interpolation_buffers[i].Lookup(pano_t);
      have_time = true;
      break;
    }
  }
  if(have_time){
    return pano_tracking_to_map;
  }else{
      std::cout << "pose graph does not contain pose at time " << pano_t << std::endl;
      exit(1);
  }
}
int main(int argc, char** argv) {
  FLAGS_alsologtostderr = true;
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);

  CHECK(!FLAGS_configuration_directory.empty())
      << "-configuration_directory is missing.";
  CHECK(!FLAGS_configuration_basename.empty())
      << "-configuration_basename is missing.";
  CHECK(!FLAGS_output_dir.empty()) << "-output_dir is missing.";
  CHECK(!FLAGS_pose_graph_filename.empty())
      << "-pose_graph_filename is missing.";

  ::cartographer::mapping::proto::PoseGraph pose_graph = ::cartographer::io::DeserializePoseGraphFromFile(FLAGS_pose_graph_filename);
  std::vector<::cartographer::transform::TransformInterpolationBuffer> transform_interpolation_buffers;
  size_t node_size=0;
  for(size_t i=0;i<pose_graph.trajectory().size();++i){
      const ::cartographer::mapping::proto::Trajectory& trajectory_proto = pose_graph.trajectory(i);
      node_size+=trajectory_proto.node_size();
      ::cartographer::transform::TransformInterpolationBuffer transform_interpolation_buffer(trajectory_proto);
      transform_interpolation_buffers.push_back(transform_interpolation_buffer);
  }
  if (node_size == 0) {
    std::cout << "empty trajectory " << std::endl;
    return 1;
  }
  std::cout << "there are " << node_size << " nodes " << std::endl;

  tf2_ros::Buffer tf_buffer;
  cartographer_ros::ReadStaticTransformsFromUrdf(FLAGS_urdf_filename, &tf_buffer);
  
  std::string tracking_frame = "base_link";
  std::vector<Eigen::Vector3f> points_result;
  std::ofstream kf_times;

  std::ifstream pano_timestamp_file;
  std::vector<ros::Time> pano_timestamp;
  pano_timestamp_file.open(FLAGS_output_dir + "pano_timestamp.txt");
  if (pano_timestamp_file.is_open()) {
    std::string line;
    getline(pano_timestamp_file, line);
    int size = -1;
    {
      std::stringstream ss(line); 
      ss >> size;
    }
    for (int i = 0; i < size; i++) {
      getline(pano_timestamp_file, line);
      std::stringstream ss(line); 
      double timestamp;
      ss >> timestamp;
      pano_timestamp.push_back(ros::Time(timestamp));
    }
  }

  pano_timestamp_file.close();

  std::ofstream pano_pose_file;
  pano_pose_file.open(FLAGS_output_dir + "pano_pose.txt");
  for (int i = 0; i < pano_timestamp.size(); i++) {
    ::cartographer::common::Time pano_t = ::cartographer_ros::FromRos(pano_timestamp[i]);
    ::cartographer::transform::Rigid3d pano_tracking_to_map = GetPose(pano_t,transform_interpolation_buffers);
    Eigen::Matrix4f transformation = Eigen::Matrix4f::Identity();
    transformation.block<3,3>(0,0) = pano_tracking_to_map.rotation().cast<float>().normalized().toRotationMatrix();
    transformation.block<3,1>(0,3) = pano_tracking_to_map.translation().cast<float>();
    //transformation(2,3) += 0.72;
    //transformation 
    //char name[2000];
    //sprintf(name, "/home/aibee/Data/vr/pano_pose/%lu.txt", long(pano_timestamp[i].toSec()*1e3));
    //std::ofstream pose_out;
    //pose_out.open(name);

    Eigen::Quaternionf q(transformation.block<3,3>(0,0));
    pano_pose_file << q.x() << "," << q.y() << "," << q.z() << "," << q.w() << "," << transformation(0,3) << "," << transformation(1,3) << "," << transformation(2,3) << "\n";
    //pose_out << q.x() << " " << q.y() << " " << q.z() << " " << q.w() << " " << transformation(0,3) << " " << transformation(1,3) << " " << transformation(2,3) << "\n";
    //pose_out.close();
  }
  pano_pose_file.close();

  //kf_times.open(kf_time_filename);
  //    std::cout << "processed time " << (message.instantiate<sensor_msgs::PointCloud2>()->header.stamp - begin_time).toSec() << std::endl;
  //    ::cartographer::sensor::PointCloudWithIntensities point_cloud;
  //    ::cartographer::common::Time point_cloud_time;
  //    std::tie(point_cloud, point_cloud_time) = cartographer_ros::ToPointCloudWithIntensities(*message.instantiate<sensor_msgs::PointCloud2>());
  //    CHECK_EQ(point_cloud.intensities.size(), point_cloud.points.size());
  //    const ::cartographer::common::Time time = point_cloud_time;
  //    if (!transform_interpolation_buffer.Has(time)) {
  //      continue; 
  //    }
  //    const ::cartographer::transform::Rigid3d tracking_to_map = transform_interpolation_buffer.Lookup(time);
  //    const ::cartographer::transform::Rigid3d sensor_to_tracking = ::cartographer_ros::ToRigid3d(tf_buffer.lookupTransform(tracking_frame, message.instantiate<sensor_msgs::PointCloud2>()->header.frame_id, ::cartographer_ros::ToRos(time)));
  //    const ::cartographer::transform::Rigid3f sensor_to_map = (tracking_to_map*sensor_to_tracking).cast<float>();
  //    if (initial) {
  //      current_tracking_to_map = tracking_to_map; 
  //      initial = false; 
  //      long time_ns = static_cast<long>(::cartographer_ros::ToRos(point_cloud_time).toSec()*1e9);
  //      kf_times << time_ns << "\n"; 
  //    }
  //    // check if need to create new kf
  //    const ::cartographer::transform::Rigid3d delta_transform = current_tracking_to_map.inverse()*tracking_to_map;
  //    Eigen::AngleAxisd angle_axis(delta_transform.rotation());
  //    //if (delta_transform.translation().norm() > 2 || fabs(angle_axis.angle()) > 60.f*M_PI/180) {
  //    if (delta_transform.translation().norm() > 1 || fabs(angle_axis.angle()) > 60.f*M_PI/180) {
  //      std::cout << "created new kf" << std::endl;
  //      current_tracking_to_map  = tracking_to_map;
  //      long long time_ns = static_cast<long long>(::cartographer_ros::ToRos(point_cloud_time).toSec()*1e9);
  //      kf_times << time_ns << "\n"; 
  //    }
  //  }
  //}
  ////WritePlyBinary(points_result, "/home/aibee/cartographer_ws/result.ply");
  //kf_times.close();
}
