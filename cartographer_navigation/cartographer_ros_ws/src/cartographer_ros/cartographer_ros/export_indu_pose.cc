/*
 * Copyright 2016 The Cartographer Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cartographer_ros/split_string.h"
#include "gflags/gflags.h"
#include "glog/logging.h"
#include "cartographer/mapping/proto/pose_graph.pb.h"
#include "cartographer/transform/transform_interpolation_buffer.h"
#include "cartographer/io/proto_stream.h"
#include "cartographer/io/proto_stream_deserializer.h"
#include "cartographer/common/make_unique.h"
#include "cartographer_ros/time_conversion.h"
#include "cartographer_ros/msg_conversion.h"
#include "cartographer_ros/urdf_reader.h"
#include "ros/ros.h"
#include "rosbag/bag.h"
#include "rosbag/view.h"
#include "tf2_eigen/tf2_eigen.h"
#include "tf2_msgs/TFMessage.h"
#include "tf2_ros/buffer.h"
#include "urdf/model.h"
#include <iostream>
#include <fstream>

DEFINE_string(configuration_directory, "",
              "First directory in which configuration files are searched, "
              "second is always the Cartographer installation to allow "
              "including files from there.");
DEFINE_string(configuration_basename, "",
              "Basename, i.e. not containing any directory prefix, of the "
              "configuration file.");
DEFINE_string(
    urdf_filename, "",
    "URDF file that contains static links for your sensor configuration.");
DEFINE_string(pose_graph_filename, "",
              "Proto stream file containing the pose graph.");
DEFINE_bool(use_bag_transforms, true,
            "Whether to read and use the transforms from the bag.");
DEFINE_string(output_file_prefix, "",
              "Will be prefixed to all output file names and can be used to "
              "define the output directory. If empty, the first bag filename "
              "will be used.");
DEFINE_string(output_dir, "",
              "output_dir with last slash");

void WritePlyBinary(const std::vector<Eigen::Vector3f>& points, std::string output_file) {
  std::ostringstream stream;
  stream << "ply\n"
         << "format binary_little_endian 1.0\n"
         << "comment generated by Cartographer\n"
         << "element vertex " << std::setw(15) << std::setfill('0')
         << points.size() << "\n"
         << "property float x\n"
         << "property float y\n"
         << "property float z\n"
         << "end_header\n";
  const std::string out = stream.str();
  std::ofstream ply_file;
  ply_file.open(output_file);
  ply_file << out; 
  for(size_t i = 0; i < points.size(); ++i) {
    Eigen::Vector3f point = points[i];
    char buffer[12];
    memcpy(buffer, &point[0], sizeof(float));
    memcpy(buffer + 4, &point[1], sizeof(float));
    memcpy(buffer + 8, &point[2], sizeof(float));
    ply_file.write(buffer, 12);
  }
  ply_file.close();
}

int main(int argc, char** argv) {
  FLAGS_alsologtostderr = true;
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);

  CHECK(!FLAGS_configuration_directory.empty())
      << "-configuration_directory is missing.";
  CHECK(!FLAGS_configuration_basename.empty())
      << "-configuration_basename is missing.";
  CHECK(!FLAGS_output_dir.empty()) << "-output_dir is missing.";
  CHECK(!FLAGS_pose_graph_filename.empty())
      << "-pose_graph_filename is missing.";

  ::cartographer::mapping::proto::PoseGraph pose_graph = ::cartographer::io::DeserializePoseGraphFromFile(FLAGS_pose_graph_filename);

  const ::cartographer::mapping::proto::Trajectory& trajectory_proto = pose_graph.trajectory(0);
  if (trajectory_proto.node_size() == 0) {
    std::cout << "empty trajectory " << std::endl;
    return 1;
  }
  std::cout << "there are " << trajectory_proto.node_size() << " nodes " << std::endl;

  tf2_ros::Buffer tf_buffer;
  cartographer_ros::ReadStaticTransformsFromUrdf(FLAGS_urdf_filename, &tf_buffer);
  const ::cartographer::transform::TransformInterpolationBuffer transform_interpolation_buffer(trajectory_proto);
  std::string tracking_frame = "base_link";
  std::vector<Eigen::Vector3f> points_result;
  std::ofstream kf_times;


  std::ifstream indu_timestamp_file;
  std::vector<ros::Time> indu_timestamp;// 存储文件中读取的timestamp
  indu_timestamp_file.open(FLAGS_output_dir + "data.csv");//读取当前相机数据下的时间戳文件
  std::ofstream indu_pose_file;// 输出的pose文件
  indu_pose_file.open(FLAGS_output_dir + "indu_pose.txt"); 
  if (indu_timestamp_file.is_open()) {
    std::string line;
    std::string first_line;
    getline(indu_timestamp_file, first_line);// no senses
    std::cout << "first line:" << first_line << std::endl;
    while( getline(indu_timestamp_file, line) )
    {
        // read timestamp with each picture from industrial camera
      std::cout << "raw timestamp string:" << line << std::endl;      
      std::string timestamp_str;

      std::stringstream s1(line); 
      getline(s1, timestamp_str, ','); // read time, throw .jpg
      std::stringstream s2(timestamp_str);
      long long timestamp;
      s2 >> timestamp;
      std::cout << "current timestamp:" << timestamp << std::endl;
      ros::Time timestamp_ros;
      timestamp_ros.sec  =  timestamp/1000000000;
      timestamp_ros.nsec =  timestamp - timestamp_ros.sec*1000000000;
      std::cout << "timestamp_ros.sec:" << timestamp_ros.sec << std::endl;
      std::cout << "timestamp_ros.nsec:" << timestamp_ros.nsec << std::endl;


      // find pos with each timestamp
      ::cartographer::common::Time indu_t = ::cartographer_ros::FromRos(timestamp_ros);
      if (!transform_interpolation_buffer.Has(indu_t)) { // no find
        std::cout << "pose graph does not contain pose at time " << timestamp_ros << std::endl;
        //exit(1);
        continue;
      }
      ::cartographer::transform::Rigid3d indu_tracking_to_map = transform_interpolation_buffer.Lookup(indu_t);// find pos-T4*4
      Eigen::Matrix4f transformation = Eigen::Matrix4f::Identity();
      transformation.block<3,3>(0,0) = indu_tracking_to_map.rotation().cast<float>().normalized().toRotationMatrix();// obtain RotationMatrix
      transformation.block<3,1>(0,3) = indu_tracking_to_map.translation().cast<float>(); // obtain translation
      //transformation(2,3) += 0.72;// 用于全景相机
  

      Eigen::Quaternionf q(transformation.block<3,3>(0,0)); 
      indu_pose_file << timestamp_str << "," << q.x() << "," << q.y() << "," << q.z() << "," << q.w() << "," << transformation(0,3) << "," << transformation(1,3) << "," << transformation(2,3) << "\n";

    }
  }
  indu_timestamp_file.close();
  indu_pose_file.close();

  //kf_times.open(kf_time_filename);
  //    std::cout << "processed time " << (message.instantiate<sensor_msgs::PointCloud2>()->header.stamp - begin_time).toSec() << std::endl;
  //    ::cartographer::sensor::PointCloudWithIntensities point_cloud;
  //    ::cartographer::common::Time point_cloud_time;
  //    std::tie(point_cloud, point_cloud_time) = cartographer_ros::ToPointCloudWithIntensities(*message.instantiate<sensor_msgs::PointCloud2>());
  //    CHECK_EQ(point_cloud.intensities.size(), point_cloud.points.size());
  //    const ::cartographer::common::Time time = point_cloud_time;
  //    if (!transform_interpolation_buffer.Has(time)) {
  //      continue; 
  //    }
  //    const ::cartographer::transform::Rigid3d tracking_to_map = transform_interpolation_buffer.Lookup(time);
  //    const ::cartographer::transform::Rigid3d sensor_to_tracking = ::cartographer_ros::ToRigid3d(tf_buffer.lookupTransform(tracking_frame, message.instantiate<sensor_msgs::PointCloud2>()->header.frame_id, ::cartographer_ros::ToRos(time)));
  //    const ::cartographer::transform::Rigid3f sensor_to_map = (tracking_to_map*sensor_to_tracking).cast<float>();
  //    if (initial) {
  //      current_tracking_to_map = tracking_to_map; 
  //      initial = false; 
  //      long time_ns = static_cast<long>(::cartographer_ros::ToRos(point_cloud_time).toSec()*1e9);
  //      kf_times << time_ns << "\n"; 
  //    }
  //    // check if need to create new kf
  //    const ::cartographer::transform::Rigid3d delta_transform = current_tracking_to_map.inverse()*tracking_to_map;
  //    Eigen::AngleAxisd angle_axis(delta_transform.rotation());
  //    //if (delta_transform.translation().norm() > 2 || fabs(angle_axis.angle()) > 60.f*M_PI/180) {
  //    if (delta_transform.translation().norm() > 1 || fabs(angle_axis.angle()) > 60.f*M_PI/180) {
  //      std::cout << "created new kf" << std::endl;
  //      current_tracking_to_map  = tracking_to_map;
  //      long long time_ns = static_cast<long long>(::cartographer_ros::ToRos(point_cloud_time).toSec()*1e9);
  //      kf_times << time_ns << "\n"; 
  //    }
  //  }
  //}
  ////WritePlyBinary(points_result, "/home/aibee/cartographer_ws/result.ply");
  //kf_times.close();
}
