

# costmap_2D

> -  costmap 使用了传感器数据和来自固态地图的信息，
通过costmap_2d::Costmap2DROS对象(Object)，来保存和更新关于障碍物的信息。

> - costmap实例化了就成了Layer, 通过Costmap2DROS类来实例化，放在了以LayeredCostmap类下的对象里，由LayeredCostmap管理。

**地图类型**
生成costmap_2d::Costmap2DROS有2中方式：
- `static_map` seed it with a user-generated static map
- `rolling_window` give it a width and height and to set the rolling_window parameter to be true
> rolling_window parameter 让机器人处在costmap正中间，当机器人走太远时，放下障碍物。这种一般用在里程计调整架构（odometric coordinate frame）中，这种架构里，机器人只关心在一个local area里的障碍物。这里涉及到的rolling_window参数是用来设置在机器人移动过程中是否需要滚动窗口，以保持机器人处于中心位置。


**注意 frame_id and tf_tree**
- global_frame          /map
- robot_base_frame      /base_link

- footprint 机器人的垂直投影




## costmap的配置文件

> 导航功能包使用两种代价地图存储周围环境中的障碍信息，一种用于全局路径规划，一种用于本地路径规划和实时避障。两种代价地图需要使用一些共同和独立的配置文件：
    - 通用配置文件      costmap_common_params.yaml  global & local每人一个   
    - 全局规划配置文件   global_costmap_params.yaml
    - 本地规划配置文件   local_costmap_params.yaml

1. **通用配置文件**
> costmap用来存储周围环境的障碍信息，其中需要注明地图关注的机器人传感器消息，以便于地图信息进行更行
所以 costmap_common_param 传感器消息的相关配置


```
obstacle_range: 2.5
raytrace_range: 3.0
max_obstacle_height: 0.6
min_obstacle_height: 0.0
// 用来设置costmap中障碍物的相关阈值，
// obstacle_range参数用来设置机器人检测障碍物的最大范围，设置为2.5意为在2.5米范围内检测到的障碍信息
// raytrace_range参数用来设置机器人检测自由空间的最大范围，设置为3.0意为在3米范围内，机器人将根据传感器的信息，清除范围内的自由空间

# footprint: [[x0, y0], [x1, y1], ... [xn, yn]]  
robot_radius: 0.165
# robot_radius: 0.5
# inflation_radius: 0.1
inflation_radius: 0.5
//这些参数用来设置机器人在二维地图上的占用面积，如果机器人外形是圆形，则需要设置机器人的外形半径。所有参数以机器人的中心作为坐标（0，0）点
// inflation_radius参数是设置障碍物的膨胀参数，也就是机器人应该与障碍物保持的最小安全距离，这里设置为0.55意为为机器人规划的路径应该与障碍物保持0.5米以上的安全距离。


observation_sources: scan
scan: {data_type: LaserScan, topic: /scan, marking: true, clearing: true, expected_update_rate: 0}

// observation_sources参数列出了代价地图需要关注的所有传感器信息
// marking和clearing参数用来表示是否需要使用传感器的实时信息来添加或清楚代价地图中的障碍物信息
```

2. **全局costmap配置文件**


```
global_costmap:
   global_frame: /map
   robot_base_frame: /base_link
// global costmap在/map参考系下运行，
// robot_base_frame指定参考系，用于获取运动中机器人的位姿

   update_frequency: 1.0
   publish_frequency: 0

// golbal costmap 更新频率和用于可视化时地图发布频率

   static_map: true
   rolling_window: false
// 一般global costmap使用static_map, local_costmap使用rolling_windows 

   resolution: 0.05
   transform_tolerance: 1.0
   map_type: costmap
//地图的分辨率， tf获取时，数据的时间的tolerance   

```

3. **局部costmap配置文件**

```
local_costmap:
   global_frame: /odom
   robot_base_frame: /base_link

   update_frequency: 3.0
   publish_frequency: 1.0

   static_map: false
   rolling_window: true
// 一般global costmap使用static_map, local_costmap使用rolling_windows    

   width: 6.0
   height: 6.0
   resolution: 0.05
   transform_tolerance: 1.0
   map_type: costmap

```



## costmap_2d::Costmap2D  CLASS
> 实现了基础的数据结构，用来存储和读取2D costmap的数据结构。


## layeredCostmap 
> 实例化不同的layer  plugins, 并且计算一个总计的 score
用来keep track of each of the layers

**每个层是在Costmap2DROS中，用pluginlib来实例化，并加入到LayeredCostmap类的对象中**
- `Static Map Layer` - The static map layer represents a largely unchanging portion of the costmap, like those generated by SLAM.
- `Obstacle Map Layer` - The obstacle layer tracks the obstacles as read by the sensor data. The ObstacleCostmapPlugin marks and raytraces obstacles in two dimensions, while theVoxelCostmapPlugin does so in three dimensions.
- `Inflation Layer` - The inflation layer is an optimization that adds new values around lethal obstacles (i.e. inflates the obstacles) in order to make the costmap represent the configuration space of the robot.
- `Other Layers` - Other layers can be implemented and used in the costmap via pluginlib. Any additional plugins are welcomed to be listed and linked to below.




## Costmap2DPublisher
> A tool to periodically publish visualization data from a Costmap2D

发布话题：
/costmap
/costmap_updates

ros costmap 发布的时候，需要将值映射到-1～100
    - -1 unknown
    - 0 no obstable
    - 99 inscribed obstacle 内切障碍物
    - 100 lethal obstacle 致命的障碍物，置信度高
    - 1-252 映射到 1～98

## costmap_2d

- size_x width
- size_y heigh

**流程**
1. check frame_id  global_frame && robot_base_frame
2. check if we want a `rolling window` version of the costmap
3. layered_costmap_ = new `LayeredCostmap`(global_frame_, rolling_window, track_unknown_spluginspace);
4. load paugin layer, don't have `plugins`, resetOldParameters()
    - static_layer
    - obstacle_layer
    - inflation_layer
5. topic sub & pub
    - sub footprint_topic ==> Costmap2DROS::setUnpaddedRobotFootprintPolygon
    - pub footprint  ==> setUnpaddedRobotFootprint(makeFootprintFromParams(private_nh));

6. costmap2d publisher
    publisher_ = new `Costmap2DPublisher`(&private_nh, layered_costmap_->getCostmap(), global_frame_, "costmap", always_send_full_costmap);

7.  启动定时器createTimer ---> Costmap2DROS::`movementCB` check if the robot is moving 
    从tf中读取机器人的位置，判断机器人是否运动 （设置robot_stopped_标志位）

8.  启动 dynamic reconfigure server ---> Costmap2DROS::`reconfigureCB`

9. map_update_thread
    - map_update_thread_ = new boost::thread(boost::bind(&Costmap2DROS::`mapUpdateLoop`, this, map_update_frequency));
    - **updateMap()**
    - **publishCostmap()**
